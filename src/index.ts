import cron from "node-cron";
import nodemailer from "nodemailer";
import { readFileSync, existsSync } from "fs";
import { runDeepResearchAgent } from "./agent.js";
import {
  getDb,
  closeDb,
  getActiveTopics,
  getTopics,
  saveReport,
  createTopic,
} from "./db.js";
import { startWebServer } from "./web.js";
import { sanitizeErrorForLog } from "./utils/errors.js";
import { processReportMemory } from "./memory.js";
import { generateWeeklySummary } from "./summary.js";
import {
  isPipelineRunning,
  setPipelineRunning,
  setLastRunInfo,
  setCronConfig,
  registerRunFunction,
} from "./pipeline.js";

export { getPipelineStatus, triggerManualRun } from "./pipeline.js";
export type { PipelineStatus } from "./pipeline.js";

/**
 * Main Orchestration: Cron + Agent + Email
 * Reads topics from DB, runs research agent for each, saves reports, sends email
 */

const CRON_SCHEDULE = process.env.CRON_SCHEDULE || "0 9 * * *"; // 9 AM daily by default

let cronJob: any = null;

/**
 * Send email with compiled research reports
 */
async function sendResearchEmail(
  reports: string[],
  topics: string[],
): Promise<void> {
  try {
    const smtpHost = process.env.SMTP_HOST;
    const smtpPort = parseInt(process.env.SMTP_PORT || "587", 10);
    const smtpSecure = process.env.SMTP_SECURE === "true";
    const smtpUser = process.env.SMTP_USER;
    const smtpPass = process.env.SMTP_PASS;
    const smtpFrom = process.env.SMTP_FROM || "research-agent@example.com";
    const smtpTo = process.env.SMTP_TO;

    if (!smtpHost || !smtpUser || !smtpPass || !smtpTo) {
      console.warn(
        "[Email] SMTP configuration incomplete, skipping email send",
      );
      return;
    }

    const transporter = nodemailer.createTransport({
      host: smtpHost,
      port: smtpPort,
      secure: smtpSecure,
      auth: {
        user: smtpUser,
        pass: smtpPass,
      },
    });

    // Compile HTML email body
    const emailBody = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body { font-family: Arial, sans-serif; color: #333; }
    .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
    .header h1 { margin: 0; font-size: 24px; }
    .header p { margin: 5px 0 0 0; font-size: 14px; opacity: 0.9; }
    .report { background: #f8f9fa; padding: 15px; margin-bottom: 15px; border-left: 4px solid #667eea; border-radius: 4px; }
    .report h3 { margin: 0 0 10px 0; color: #667eea; }
    .footer { border-top: 1px solid #ddd; margin-top: 20px; padding-top: 15px; font-size: 12px; color: #999; }
  </style>
</head>
<body>
  <div class="header">
    <h1>ðŸ”¬ Deep Research Agent Report</h1>
    <p>Automated Research Surveillance - ${new Date().toLocaleDateString()}</p>
  </div>

  <h2>Research Summary</h2>
  <p>Researched topics: <strong>${topics.length}</strong></p>

  <div class="reports">
    ${reports.map((report) => `<div class="report">${report}</div>`).join("\n")}
  </div>

  <div class="footer">
    <p>This is an automated report generated by the Deep Research Agent.</p>
    <p>Access the dashboard: <a href="http://localhost:3000/dashboard">Deep Research Dashboard</a></p>
    <p>Report generated at ${new Date().toISOString()}</p>
  </div>
</body>
</html>
    `;

    const mailOptions = {
      from: smtpFrom,
      to: smtpTo,
      subject: `[Research] Veille Technologique - ${new Date().toLocaleDateString()}`,
      html: emailBody,
    };

    const info = await transporter.sendMail(mailOptions);
    console.log("[Email] Report sent successfully:", info.messageId);
  } catch (error) {
    console.error("[Email] Failed to send email:", error);
  }
}

/**
 * Execute research for all active topics
 */
async function executeResearchCycle(): Promise<void> {
  if (isPipelineRunning()) {
    console.warn("[Pipeline] Research cycle already in progress, skipping");
    return;
  }

  setPipelineRunning(true);
  const startedAt = new Date().toISOString();
  let topicsProcessed = 0;
  let reportsGenerated = 0;

  try {
    console.log("[Cron] Starting research cycle...");
    console.log(`[Cron] Timestamp: ${startedAt}`);

    const startTime = Date.now();

    // Get active topics from database
    const topics = await getActiveTopics();

    if (topics.length === 0) {
      console.warn("[Cron] No active topics found");
      return;
    }

    console.log(
      `[Cron] Found ${topics.length} active topic(s): ${topics.map((t) => t.name).join(", ")}`,
    );

    const reports: string[] = [];

    // Research each topic
    for (const topic of topics) {
      try {
        console.log(`[Cron] Researching topic: "${topic.name}"`);

        // Run the agent
        const htmlReport = await runDeepResearchAgent(topic.name);

        // Save to database
        const savedReport = await saveReport(topic.name, htmlReport, undefined);

        // Process through memory system for novelty tracking
        try {
          const memoryResult = await processReportMemory(
            topic.name,
            savedReport.id,
            htmlReport,
          );
          if (memoryResult.isNovel) {
            reports.push(htmlReport);
            console.log(
              `[Cron] âœ“ Completed research for "${topic.name}" (${memoryResult.novelFindings.length} novel findings)`,
            );
          } else {
            console.log(
              `[Cron] âœ“ Completed research for "${topic.name}" (no novel content â€” skipping email)`,
            );
          }
        } catch (memError) {
          console.warn(
            `[Cron] Memory processing failed for "${topic.name}":`,
            memError,
          );
          reports.push(htmlReport);
          console.log(`[Cron] âœ“ Completed research for "${topic.name}"`);
        }
      } catch (error) {
        console.error(`[Cron] âœ— Error researching "${topic.name}":`, error);
        // Continue with other topics instead of failing
      }
    }

    // Send email with all reports
    if (reports.length > 0) {
      const topicNames = topics.slice(0, reports.length).map((t) => t.name);
      await sendResearchEmail(reports, topicNames);
    }

    const duration = Date.now() - startTime;
    topicsProcessed = topics.length;
    console.log(
      `[Cron] Research cycle completed in ${(duration / 1000).toFixed(1)}s`,
    );

    setLastRunInfo({
      startedAt,
      completedAt: new Date().toISOString(),
      durationMs: duration,
      topicsProcessed,
      reportsGenerated: reports.length,
      status:
        reports.length === topics.length
          ? "success"
          : reports.length > 0
            ? "partial"
            : "error",
    });
  } catch (error) {
    console.error("[Cron] Research cycle failed:", error);
    setLastRunInfo({
      startedAt,
      completedAt: new Date().toISOString(),
      durationMs: Date.now() - new Date(startedAt).getTime(),
      topicsProcessed,
      reportsGenerated,
      status: "error",
      error: sanitizeErrorForLog(error),
    });
  } finally {
    setPipelineRunning(false);
  }
}

/**
 * Initialize and schedule cron job
 */
export function initializeCron(): void {
  // Register the research cycle function for manual triggers
  registerRunFunction(executeResearchCycle);

  try {
    console.log(
      `[Cron] Scheduling research with expression: "${CRON_SCHEDULE}"`,
    );

    cronJob = cron.schedule(CRON_SCHEDULE, () => {
      console.log("\n" + "=".repeat(60));
      console.log("[Cron] Executing scheduled research...");
      console.log("=".repeat(60));

      executeResearchCycle().catch((error) => {
        console.error("[Cron] Unhandled error in research cycle:", error);
      });
    });

    // Weekly summary generation (every Sunday at 8 PM)
    cron.schedule("0 20 * * 0", () => {
      console.log("\n" + "=".repeat(60));
      console.log("[Cron] Generating weekly multi-topic summary...");
      console.log("=".repeat(60));

      generateWeeklySummary().catch((error) => {
        console.error("[Cron] Weekly summary generation failed:", error);
      });
    });

    console.log("[Cron] Weekly summary scheduled: Every Sunday at 8 PM");

    console.log("[Cron] Cron job initialized successfully");
    setCronConfig(CRON_SCHEDULE, true);
  } catch (error) {
    console.error("[Cron] Failed to initialize cron job:", error);
    process.exit(1);
  }
}

/**
 * Stop cron job
 */
export function stopCron(): void {
  if (cronJob) {
    cronJob.stop();
    console.log("[Cron] Cron job stopped");
  }
}

/**
 * Seed database with initial topics from sujets.json if empty
 */
async function seedDatabase(): Promise<void> {
  try {
    const topics = await getTopics();

    if (topics.length > 0) {
      console.log(`[DB] Database already has ${topics.length} topics`);
      return;
    }

    console.log("[DB] Seeding database with topics from sujets.json...");

    // Try multiple paths for sujets.json
    const paths = [
      `${import.meta.dirname}/../sujets.json`,
      `${process.cwd()}/sujets.json`,
    ];

    let sujetContent: string | null = null;
    for (const p of paths) {
      if (existsSync(p)) {
        sujetContent = readFileSync(p, "utf-8");
        break;
      }
    }

    if (!sujetContent) {
      console.warn("[DB] sujets.json not found, skipping seed");
      return;
    }

    const sujetTopics: string[] = JSON.parse(sujetContent);

    let seeded = 0;
    for (const topicName of sujetTopics) {
      try {
        await createTopic(topicName);
        console.log(`[DB] Created topic: "${topicName}"`);
        seeded++;
      } catch (error) {
        console.warn(
          `[DB] Skipped topic "${topicName}":`,
          sanitizeErrorForLog(error),
        );
      }
    }

    console.log(`[DB] Seeded ${seeded}/${sujetTopics.length} topics`);
  } catch (error) {
    console.error("[DB] Failed to seed database:", sanitizeErrorForLog(error));
  }
}

/**
 * Main entry point
 */
export async function main(): Promise<void> {
  try {
    console.log("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    console.log("â•‘  Deep Research Agent - Initialization      â•‘");
    console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    // Initialize database
    console.log("[Init] Initializing database...");
    await getDb();
    await seedDatabase();

    // Start web server
    console.log("[Init] Starting web server...");
    const webServerPromise = startWebServer();

    // Initialize cron
    console.log("[Init] Initializing cron scheduler...");
    initializeCron();

    console.log("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    console.log("â•‘  Deep Research Agent - RUNNING            â•‘");
    console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    console.log("[Init] System ready!");
    console.log(
      `[Init] Dashboard: http://localhost:${process.env.PORT || 3000}/dashboard`,
    );
    console.log(`[Init] Next research scheduled: ${CRON_SCHEDULE}\n`);

    // Handle graceful shutdown
    process.on("SIGINT", () => {
      console.log("\n[Shutdown] Received SIGINT signal...");
      stopCron();
      closeDb();
      process.exit(0);
    });

    process.on("SIGTERM", () => {
      console.log("\n[Shutdown] Received SIGTERM signal...");
      stopCron();
      closeDb();
      process.exit(0);
    });

    // Keep process running
    await webServerPromise;
  } catch (error) {
    console.error("[Init] Startup failed:", error);
    process.exit(1);
  }
}

// Run if this is the main module
if (import.meta.main) {
  main().catch((error) => {
    console.error("[Main] Fatal error:", error);
    process.exit(1);
  });
}
